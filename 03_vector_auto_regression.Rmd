---
title: "Vector Auto Regression"
author: "Logan Wu"
date: "1/16/2019"
output: rmarkdown::github_document
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=T, cache=T)
library(data.table)
library(sf)
library(leaflet)
library(spdep)                     # easily create weight matrices
library(starma)
library(forecast)
library(ggcorrplot)
library(tidyverse)
library(xts)
library(plotly)
```

## Load data

```{r}
# read in a manageable portion of the dataset for now
raw.ts <- fread("data/Pedestrian_volume__updated_monthly_.csv", nrows=50000)
raw.ts[,Date_Time := as.POSIXct(Date_Time, format="%m/%d/%Y %I:%M:%S %p")]
```

## Process TS data

```{r}
data.ts = raw.ts %>%
  dplyr::select(-ID) %>%
  dplyr::select(Date_Time, Sensor_Name, Hourly_Counts) %>%
  spread(key=Sensor_Name, value=Hourly_Counts) %>%
  # dplyr::select(-Date_Time) %>%
  as.xts %>%
  as.zoo %>%
  na.contiguous # analysis does not include missing data
  # stcenter# %>%
names(data.ts) = make.names(names(data.ts))
```

## Perform differencing

Confirm that each sensor series is stationary as we would expect

```{r}
for (i in seq_along(colnames(data.ts))) {
  print(ndiffs(data.ts[,i], test="adf"))
}
```

Test to perform seasonal differencing. Weekly differencing only seems to give the best PACF plot.

```{r, fig.height=3}
# data.diff = data.ts %>%
#   diff(lag=168)
# plot(data.diff[,2])
# pacf(data.diff[,2])
```

Split into train/test sets. Later this can turn into a rolling train/test.

```{r}
frac = 0.8
X.train = head(data.ts, round(nrow(data.ts)*frac))
X.test = tail(data.ts, round(nrow(data.ts)*(1-frac)))

X.train.diff = X.train %>%
  diff(lag=168)
```

Perform vector autoregression. Assume the moving average component is not necessary because the series is stationary. [Useful link](https://stats.stackexchange.com/questions/191851/var-forecasting-methodology)

```{r}
library(vars)

# lag optimisation
VARselect(X.train.diff, lag.max=10, type="both", season=168)

myvar = VAR(X.train.diff, p=2, season=168)

serial.test(myvar, lags.pt=10, type="PT.asymptotic")
# arch.test(myvar, lags.multi=10)
# summary(myvar)
```

Predictions

```{r}
prd <- predict(myvar, n.ahead = nrow(X.test))
fcst = diffinv(prd$fcst$Webb.Bridge[,1], lag=168, xi=tail(X.train[,"Webb.Bridge"], 168)) %>%
  tail(nrow(X.test))
fcst.all = lapply(prd$fcst,
                  function(X) X[,"fcst"]
  )
fcst.all = sapply(names(prd$fcst), function(N) diffinv(fcst.all[[N]],
                                                       lag=168,
                                                       xi=tail(X.train[,N], 168)
                                                       )
                  ) %>%
  as.data.frame %>%
  tail(nrow(X.test)) %>%
  mutate(time = index(X.test)) %>%
  gather(key="location", value="value", -time)
  
X.train.all = X.train %>%
  as.data.frame %>%
  mutate(time = as.POSIXct(rownames(.)),
         key="train") %>%
  gather(key="location", value="value", -time, -key)
X.obs.all = X.test %>%
  as.data.frame %>%
  mutate(time = as.POSIXct(rownames(.)),
         key="obs") %>%
  gather(key="location", value="value", -time, -key)
X.fcst.all = fcst.all %>%
  mutate(key="fcst") %>%
  gather(key="location", value="value", -time, -key)
X.all = X.train.all %>% rbind(X.obs.all) %>% rbind(X.fcst.all) %>%
  mutate(key=factor(key), location=factor(location)) %>%
  arrange(time)

# plt.train = data.frame(train=X.train[,"Webb.Bridge"]) %>%
#   mutate(time = as.POSIXct(rownames(.))) %>%
#   gather(key="key", value="value", -time) %>%
#   tail(nrow(X.test)*1.5) # arbitrary for plotting
# 
# plt.test = data.frame(fcst.all[,"Webb.Bridge"], observed=X.test[,"Webb.Bridge"]) %>%
#   mutate(time = as.POSIXct(rownames(.)),
#          resid = fcst-observed) %>%
#   gather(key="key", value="value", -time)

# g1 = ggplot(mapping=aes(x=time, y=value, color=key)) +
#   geom_line(data=plt.train, size=0.25) +
#   geom_line(data=plt.test, size=0.25)
# g1
# ggplotly(g1)

ggplot(X.all %>% filter(location %in% levels(X.all$location)[1:6],
                        time > as.POSIXct("2009-07-01")),
       aes(x=time, y=value, color=key)) +
  geom_line() +
  facet_wrap(.~location)
```

Error quantification

```{r, eval=F}
MAE = mean(plt.test %>% filter(key=="resid") %>% pull(value) %>% abs)
MAE  # people per hour
```