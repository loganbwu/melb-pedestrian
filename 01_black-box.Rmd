---
title: "Black Box Methods"
author: "Logan Wu"
date: "1/8/2019"
output: rmarkdown::github_document
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=T, cache=T)
library(tidyverse)
library(data.table)
library(sf)
library(leaflet)
library(spdep) #easily create weight matrices
library(starma)
library(forecast)
library(ggcorrplot)
```

## Load data

```{r}
# read in a manageable portion of the dataset for now
raw.ts <- fread("data/Pedestrian_volume__updated_monthly_.csv")
raw.ts[,Date_Time := as.POSIXct(Date_Time, format="%m/%d/%Y %I:%M:%S %p")]
```

## Process data

Feature vector includes:

- n hours of lags
- Time of day
- Day of week
- Sensor name or ID

Could include:

- Month of year, and year (or some other trend term)
- Public holiday

```{r}
n = 3

data.ts = raw.ts %>%
  select(Date_Time, Sensor_Name, Hourly_Counts, Time, Day) %>%
  spread(key=Sensor_Name, value=Hourly_Counts, -c(Time:Day))# %>%
  select(-Date_Time) %>%
  mutate(Day = factor(Day)) %>%
  as.ts %>%
  na.contiguous %>% # analysis does not include missing data
  as.data.frame
data.ts = data.ts[,1:4]
# data.lag = data.ts

lags = list()
for (i in 1:n) {
  lags[[i]] = data.ts %>% select(-Time, -Day) %>% mutate_all(function (x) lead(x, i)) %>%
  rename_all(function(x) paste0(x,".lag", i))
}
lags = do.call(cbind, lags)

# append the lags onto each current measurement
X = list()
for (i in 1:(ncol(data.ts)-n+1)) {
  X[[i]] = cbind(Hourly_Counts=data.ts[,i+n-1], Day=data.ts[,n-1], Time=data.ts[,1], Sensor_Name=names(data.ts)[i+n-1], lags)
}
X = do.call(rbind, X) %>%
  drop_na()
X %>% head
```

## Test RF

```{r}
library(ranger)
names(X) = make.names(names(X))
n.test = 500
X.train = X %>% head(nrow(X) - n.test)
X.test = X %>% tail(n.test)
y.test = X.test %>% pull(Hourly_Counts)
```

Exclude the time and weekday. Purely regressed on the past three hours.

```{r}
rf <- ranger(Hourly_Counts ~ . -Time -Day, data=X.train)
pred <- predict(rf, X.test)
plot(log(y.test), log(pred$predictions))
plot(sqrt((y.test-pred$predictions)^2))
print(sum(sqrt((y.test-pred$predictions)^2)))

plt.df = data.frame(actual=y.test, pred=pred$predictions) %>%
  mutate(id = row_number()) %>%
  gather(key="method", value="value", -id)
ggplot(plt.df, aes(x=id, y=value, color=method)) +
  geom_line()
```

Introduce time and weekday. Would expect it to improve.

```{r}
rf2 <- ranger(Hourly_Counts ~ ., data=X.train)
pred2 <- predict(rf2, X.test)
plot(log(y.test), log(pred2$predictions))
plot(sqrt((y.test-pred2$predictions)^2))
print(sum(sqrt((y.test-pred2$predictions)^2)))

plt.df2 = data.frame(actual=y.test, pred=pred2$predictions) %>%
  mutate(id = row_number()) %>%
  gather(key="method", value="value", -id)
ggplot(plt.df2, aes(x=id, y=value, color=method)) +
  geom_line()
```

Note: ID is just index, not time.
Early indications are good but needs proper model comparison. Comparison required against univariate TS is needed.
